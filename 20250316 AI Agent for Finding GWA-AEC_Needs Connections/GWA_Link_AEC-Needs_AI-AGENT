# THIS IS THE TINKER CODE FILE
import warnings
warnings.filterwarnings("ignore", category=Warning)  # Add this to handle SSL warnings

# Configuration flags
USE_OPENAI = True        # Set to False to use dummy responses instead of OpenAI
SKIP_PROPOSITIONS = True  # Set to True to skip generating propositions
SKIP_STAKEHOLDER_MAP = True  # Set to True to skip creating stakeholder map
SKIP_CATEGORIZATION = False  # Set to True to skip categorizing leads

import os
from typing import List, Dict, Any
from langgraph.graph import Graph
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage
from langchain_community.utilities.google_search import GoogleSearchAPIWrapper
import networkx as nx
import matplotlib.pyplot as plt
import pandas as pd
import sys
from dotenv import load_dotenv, set_key
from pathlib import Path
from tqdm import tqdm
import time  # Add this import at the top

def get_dummy_response(prompt: str) -> str:
    """Generate dummy responses when OpenAI is disabled"""
    if "categorize" in prompt.lower():
        return "ConTech Startup"
    elif "connection" in prompt.lower() or "synergy" in prompt.lower():
        return "Yes"
    else:
        return "Sample proposition: Let's collaborate on a pilot project to implement your technology."

def setup_api_keys():
    """Setup API keys with user input if not found in environment"""
    # Load existing .env file or create if doesn't exist
    env_path = Path(get_script_dir()) / '.env'
    env_path.touch(exist_ok=True)
    load_dotenv(env_path)
    
    # Check for OpenAI API key
    if USE_OPENAI and not os.getenv('OPENAI_API_KEY'):
        print("\n‚ö†Ô∏è OPENAI_API_KEY not found in environment variables")
        api_key = input("Please enter your OpenAI API key: ").strip()
        set_key(env_path, 'OPENAI_API_KEY', api_key)
        os.environ['OPENAI_API_KEY'] = api_key
        print("‚úÖ OpenAI API key saved")

# Initialize API clients after setting up keys
def initialize_clients():
    clients = {}
    
    if USE_OPENAI:
        clients["llm"] = ChatOpenAI(model="gpt-4o-mini")
    else:
        print("‚ÑπÔ∏è Using dummy responses instead of OpenAI")
        clients["llm"] = type('DummyLLM', (), {
            'invoke': lambda self, messages: type('DummyResponse', (), {'content': get_dummy_response(messages[-1].content)})()
        })()
    
    return clients

def get_script_dir():
    """Get the directory where the script is located"""
    return os.path.dirname(os.path.abspath(__file__))

class AECNetworkAgent:
    def __init__(self, clients):
        self.categories = {
            "ConTech Startup": [],
            "ConTech Investors": [],
            "ConTech Adopter": [],
        }
        self.connections = []
        self.llm = clients["llm"]
        self.output_dir = get_script_dir()
        
    def search_and_collect_data(self) -> Dict[str, List[Dict]]:
        print("\nüîç OpenAI Search Results:")
        print("==================================================")
        
        try:
            openai_prompt = """Please provide a list of 100 real companies in total. Find approximately 33 companies for each category:
            1) startups, innovators, creators, technology suppliers, early stage companies, 
            2) corporate venture capital, private equity, venture capitalists, investors, 
            3) adopters, and 
            in the AEC (Architecture, Engineering, Construction) technology space.

            Use the following urlsand to complete this search task.
            - https://contechroundup.substack.com/
            - https://builtworlds.com/
            - https://builtworlds.com/insights/2024-builtworlds-top-50-venture-investors/
            - https://builtworlds.com/insights/2024-top-50-venture-investments-deals/
            - https://builtworlds.com/insights/2025-building-tech-top-50-list/
            - https://builtworlds.com/insights/2024-adoption-leaders-50-list/
            - https://builtworlds.com/insights/2024-global-innovators-list-new/
            - https://builtworlds.com/insights/2025-preconstruction-tech-top-50-list/
            - https://www.constructiondive.com/
            - https://www.constructiondive.com/news/contech-startups-to-watch-2024/632886/
            - https://brickmortar.vc/portfolio 
            
            For each, include:
            Company: [name]
            Description: [description]
            URL: [url]
            
            Focus on companies involved in robotics, AI, and construction technology.
            Format each entry exactly as shown above, with each field on a new line."""
            
            print("Generating company list, this will take OpenAi a minute to complete, be patient... ")
            
            # Make the API call
            response = self.llm.invoke([
                SystemMessage(content="You are a construction technology industry expert with extensive knowledge of the AEC sector."),
                HumanMessage(content=openai_prompt)
            ])
            
            # Parse the response into structured data
            results = {"openai": []}
            company_data = self._parse_openai_response(response.content)
            if company_data:
                results["openai"].extend(company_data)
        
        except Exception as e:
            print("\n‚ùå Error generating companies:", str(e))
            return {"openai": []}
        
        # Display results summary
        print("\nFound companies:")
        print("-" * 30)
        for i, company in enumerate(results["openai"], 1):
            print(f"\n{i}. {company.get('name', 'Unknown')}")
            print(f"   Description: {company.get('description', 'N/A')}")
            print(f"   URL: {company.get('url', 'N/A')}")
        
        print("\n" + "=" * 50)
        print(f"üìä Using {len(results['openai'])} OpenAI-generated companies...")
        return results

    def _parse_openai_response(self, content: str) -> List[Dict]:
        """Helper method to parse OpenAI response into structured data"""
        companies = []
        current_company = {}
        
        lines = content.strip().split('\n')
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # If we find a new company entry, save the previous one
            if line.lower().startswith("company:") and current_company:
                companies.append(current_company)
                current_company = {}
            
            # Parse the line
            if ":" in line:
                parts = line.split(":", 1)
                key = parts[0].strip().lower()
                value = parts[1].strip()
                
                if "company" in key:
                    current_company["name"] = value
                elif "description" in key:
                    current_company["description"] = value
                elif "url" in key:
                    current_company["url"] = value
        
        # Add the last company if exists
        if current_company:
            companies.append(current_company)
        
        return companies

    def categorize_leads(self, data: Dict[str, List[Dict]]) -> pd.DataFrame:
        # Use LLM to categorize each lead
        categorized_data = []
        
        # Calculate total number of leads to categorize
        total_leads = sum(len(results) for results in data.values())
        
        # Use LLM to categorize each lead with progress bar
        with tqdm(total=total_leads, desc="Categorizing companies") as pbar:
            for source, results in data.items():
                for result in results:
                    # Ensure result is a dictionary
                    if isinstance(result, str):
                        result = {
                            "name": result,
                            "description": result,
                            "url": "N/A"
                        }
                    
                    # Clean the name before using it in the prompt
                    clean_name = result.get('name', 'Unknown').replace('*', '').strip()
                    
                    categorization_prompt = f"""
                    Categorize this entity into exactly one of these categories:
                    ConTech Startup
                    ConTech Investors
                    ConTech Adopter

                    Entity information:
                    Company: {clean_name}
                    Description: {result.get('description', 'N/A')}

                    Return only the exact category name from the list above, without any additional text, symbols, or formatting.
                    """
                    
                    response = self.llm.invoke([
                        SystemMessage(content="You are a construction technology industry expert. Respond only with the exact category name."),
                        HumanMessage(content=categorization_prompt)
                    ])
                    
                    # Clean up the category response
                    category = response.content.strip()
                    # Remove any markdown formatting or special characters
                    category = category.replace('*', '').replace('`', '').replace('#', '').strip()
                    
                    categorized_data.append({
                        "Name": clean_name,
                        "Category": category,
                        "Description": result.get("description", ""),
                        "URL": result.get("url", "N/A"),
                        "Source": source
                    })
                    
                    pbar.update(1)
        
        # Create DataFrame and ensure columns are in the desired order
        df = pd.DataFrame(categorized_data)
        column_order = ["Name", "Category", "Description", "URL", "Source"]
        df = df[column_order]
        
        return df

    def create_stakeholder_map(self, df: pd.DataFrame) -> nx.Graph:
        G = nx.Graph()
        
        # Add nodes
        for _, row in df.iterrows():
            G.add_node(row["Name"], category=row["Category"])
        
        # Calculate total number of connections to check
        total_connections = sum(range(len(df)))
        
        # Use LLM to identify connections with progress bar
        with tqdm(total=total_connections, desc="Analyzing connections") as pbar:
            for i, row1 in df.iterrows():
                for j, row2 in df.iterrows():
                    if i < j:
                        connection_prompt = f"""
                        Analyze if there's a potential connection between these entities:
                        Entity 1: {row1['Name']} ({row1['Category']})
                        {row1['Description']}
                        
                        Entity 2: {row2['Name']} ({row2['Category']})
                        {row2['Description']}
                        
                        Return only 'Yes' or 'No'.
                        """
                        
                        response = self.llm.invoke([
                            SystemMessage(content="Analyze potential business connections."),
                            HumanMessage(content=connection_prompt)
                        ])
                        
                        if response.content.strip().lower() == "yes":
                            G.add_edge(row1["Name"], row2["Name"])
                        
                        pbar.update(1)
        
        return G

    def generate_propositions(self, df: pd.DataFrame) -> Dict[str, str]:
        propositions = {}
        
        for _, lead in df.iterrows():
            # First, find relevant connections for this lead
            related_companies = []
            for _, other_lead in df.iterrows():
                if other_lead['Name'] != lead['Name']:
                    connection_prompt = f"""
                    Analyze the potential synergy between:
                    Company 1: {lead['Name']} ({lead['Category']})
                    Description: {lead['Description']}
                    
                    Company 2: {other_lead['Name']} ({other_lead['Category']})
                    Description: {other_lead['Description']}
                    
                    Return only 'Yes' or 'No'.
                    """
                    
                    response = self.llm.invoke([
                        SystemMessage(content="Analyze potential business synergies."),
                        HumanMessage(content=connection_prompt)
                    ])
                    
                    if response.content.strip().lower() == "yes":
                        related_companies.append(other_lead)

            # Generate a more specific proposition focusing on connections
            proposition_prompt = f"""
            Create a personalized message for:
            Company: {lead['Name']}
            Category: {lead['Category']}
            Description: {lead['Description']}
            
            Connected Companies: {', '.join([f"{comp['Name']} ({comp['Category']})" for comp in related_companies])}

            Write a LinkedIn message (max 300 characters) that:
            1. Mentions specific ways they could collaborate with one or two of their most relevant connections
            2. Highlights a concrete business opportunity or pilot project between them that I could help with in general
            3. Focuses on mutual benefits and specific outcomes
            4. Discusses how I would like to get involved & how I think I can add significant value
            5. Has a call to action for us to further discuss
            
            Don't mention consulting or advisory services. Focus purely on the direct business opportunity between the companies & how I am add value to that and/or help them apply this model in different regions & with different companies / networks.
            """
            
            response = self.llm.invoke([
                SystemMessage(content="""
                You are crafting direct business opportunity messages.
                Focus on specific collaborations and concrete projects.
                Be direct and business-focused.
                Don't mention intermediaries or advisors.
                """),
                HumanMessage(content=proposition_prompt)
            ])
            
            propositions[lead["Name"]] = response.content
        
        return propositions

    def visualize_stakeholder_map(self, G: nx.Graph):
        plt.figure(figsize=(12, 8))
        pos = nx.spring_layout(G)
        
        # Draw nodes for each category with different colors
        colors = {
            "ConTech Startup": "skyblue",
            "ConTech Investors": "lightgreen",
            "ConTech Adopter": "salmon",
        }
        
        for category, color in colors.items():
            nodes = [node for node, attr in G.nodes(data=True) 
                    if attr.get("category") == category]
            nx.draw_networkx_nodes(G, pos, nodelist=nodes, node_color=color, 
                                 node_size=1000, alpha=0.7)
        
        # Draw edges and labels
        nx.draw_networkx_edges(G, pos, alpha=0.5)
        nx.draw_networkx_labels(G, pos)
        
        # Add legend
        legend_elements = [plt.Line2D([0], [0], marker='o', color='w', 
                         markerfacecolor=color, label=cat, markersize=10)
                         for cat, color in colors.items()]
        plt.legend(handles=legend_elements)
        
        plt.title("AEC Technology Stakeholder Network")
        plt.axis('off')
        plt.tight_layout()
        
        # Save to script directory
        output_path = os.path.join(self.output_dir, 'stakeholder_map.png')
        plt.savefig(output_path)
        plt.close()

def main():
    # Print configuration status
    print("\nüîß Configuration:")
    print(f"{'‚úÖ' if USE_OPENAI else '‚ùå'} OpenAI API: {'Enabled' if USE_OPENAI else 'Disabled'}")
    print(f"{'‚ùå' if SKIP_CATEGORIZATION else '‚úÖ'} Categorization: {'Skipped' if SKIP_CATEGORIZATION else 'Enabled'}")
    print(f"{'‚ùå' if SKIP_STAKEHOLDER_MAP else '‚úÖ'} Stakeholder Map: {'Skipped' if SKIP_STAKEHOLDER_MAP else 'Enabled'}")
    print(f"{'‚ùå' if SKIP_PROPOSITIONS else '‚úÖ'} Propositions: {'Skipped' if SKIP_PROPOSITIONS else 'Enabled'}")
    print()
    
    # Setup API keys and initialize clients
    setup_api_keys()
    clients = initialize_clients()
    
    # Create agent
    agent = AECNetworkAgent(clients)
    
    # Execute the workflow
    print("üîç Searching for leads...")
    data = agent.search_and_collect_data()
    
    if not SKIP_CATEGORIZATION:
        print("üìä Categorizing leads...")
        categorized_df = agent.categorize_leads(data)
        # Save to script directory
        output_path = os.path.join(agent.output_dir, 'categorized_leads.csv')
        categorized_df.to_csv(output_path, index=False)
    else:
        # Create a basic DataFrame without categorization
        categorized_data = []
        for source, results in data.items():
            for result in results:
                categorized_data.append({
                    "Name": result.get("name", "Unknown"),
                    "Category": "Uncategorized",
                    "Description": result.get("description", ""),
                    "URL": result.get("url", "N/A"),
                    "Source": source
                })
        categorized_df = pd.DataFrame(categorized_data)
        output_path = os.path.join(agent.output_dir, 'leads.csv')
        categorized_df.to_csv(output_path, index=False)
    
    if not SKIP_STAKEHOLDER_MAP:
        print("üï∏Ô∏è Creating stakeholder map...")
        G = agent.create_stakeholder_map(categorized_df)
        agent.visualize_stakeholder_map(G)
    
    if not SKIP_PROPOSITIONS:
        print("üìù Generating propositions...")
        propositions = agent.generate_propositions(categorized_df)
        
        # Save propositions to script directory
        output_path = os.path.join(agent.output_dir, 'propositions.txt')
        with open(output_path, 'w') as f:
            for name, proposition in propositions.items():
                f.write(f"\n{'='*50}\n")
                f.write(f"Proposition for: {name}\n")
                f.write(f"{'='*50}\n")
                f.write(f"{proposition}\n")
    
    print(f"\n‚úÖ Process complete! Check output files in: {agent.output_dir}")
    if not SKIP_CATEGORIZATION:
        print("- categorized_leads.csv")
    else:
        print("- leads.csv")
    if not SKIP_STAKEHOLDER_MAP:
        print("- stakeholder_map.png")
    if not SKIP_PROPOSITIONS:
        print("- propositions.txt")

if __name__ == "__main__":
    main()
